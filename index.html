import React, { useMemo, useRef, useState } from "react";
import Papa from "papaparse";
import QRCode from "qrcode";
import { jsPDF } from "jspdf";
import dayjs from "dayjs";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Upload, FileDown, AlertTriangle, Copy, Check } from "lucide-react";

/**
 * GKR QR Card Generator
 * - 100% client-side; no storage.
 * - CSV columns: MembershipNumber (required), Name (optional)
 * - Generates QR from raw membership number.
 * - Preview grid + duplicate detection.
 * - A4 PDF export, credit-card size 85.6 x 54 mm.
 * - Subtle crop marks, rounded corner outline, branding area.
 * - Helvetica/Inter-style font stack.
 */

const mm = (v) => v; // using jsPDF with 'mm' units

const CARD_W = 85.6; // mm (credit card)
const CARD_H = 54;   // mm
const PAGE_W = 210;  // A4 mm
const PAGE_H = 297;  // A4 mm
const MARGIN = 10;   // outer page margin mm
const GUTTER_X = 8;  // horizontal gap mm
const GUTTER_Y = 8;  // vertical gap mm

// Compute columns/rows that fit nicely on A4 with the given margins & gutters
const COLS = 2; // two columns of credit-card width
const ROWS = 4; // four rows per page (8 cards / page)

// Quiet zone around QR for reliable scans
const QR_SIZE = 34; // mm square within the card

const BRAND = {
  name: "GKR Karate",
  // Brand colours (adjustable in UI)
  primary: "#D0021B", // GKR red (approx)
  text: "#111111",
};

export default function App() {
  const [rows, setRows] = useState([]); // {number, name}
  const [logoDataUrl, setLogoDataUrl] = useState(null);
  const [csvName, setCsvName] = useState("");
  const [copyOk, setCopyOk] = useState(false);

  const duplicates = useMemo(() => {
    const seen = new Map();
    const dups = new Set();
    rows.forEach((r) => {
      const n = r.number?.trim();
      if (!n) return;
      if (seen.has(n)) dups.add(n);
      else seen.set(n, true);
    });
    return [...dups];
  }, [rows]);

  function handleCsvFile(file) {
    if (!file) return;
    setCsvName(file.name);
    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      transformHeader: (h) => h.trim(),
      complete: (res) => {
        const parsed = res.data
          .map((r) => ({
            number: (r.MembershipNumber || r.membershipnumber || r.number || r.Number || "").toString().trim(),
            name: (r.Name || r.name || "").toString().trim(),
          }))
          .filter((r) => r.number);
        setRows(parsed);
      },
    });
  }

  function handlePaste(text) {
    // Support quick paste: two columns (number, name) or single column
    const parsed = Papa.parse(text.trim(), { delimiter: ",", newline: "\n" });
    const out = [];
    parsed.data.forEach((row) => {
      if (!row || row.length === 0) return;
      if (row.length === 1) {
        const n = (row[0] || "").toString().trim();
        if (n) out.push({ number: n, name: "" });
      } else {
        const n = (row[0] || "").toString().trim();
        const nm = (row[1] || "").toString().trim();
        if (n) out.push({ number: n, name: nm });
      }
    });
    setRows(out);
  }

  async function makeQrDataUrl(text) {
    // Ensure quiet zone & high contrast
    return await QRCode.toDataURL(text, {
      errorCorrectionLevel: "M",
      margin: 1, // around modules
      scale: 8,
      color: { dark: "#000000", light: "#FFFFFF" },
    });
  }

  async function exportPdf() {
    if (!rows.length) return;
    const doc = new jsPDF({ unit: "mm", format: "a4" });

    // Font setup: use built-in Helvetica for a clean sans look similar to Helvetica Neue/Inter
    doc.setFont("helvetica", "normal");

    let x0 = MARGIN;
    let y0 = MARGIN;
    let col = 0;
    let row = 0;

    for (let i = 0; i < rows.length; i++) {
      if (i > 0) {
        col++;
        if (col >= COLS) {
          col = 0;
          row++;
          if (row >= ROWS) {
            // New page
            doc.addPage();
            row = 0;
          }
        }
      }

      const x = MARGIN + col * (CARD_W + GUTTER_X);
      const y = MARGIN + row * (CARD_H + GUTTER_Y);

      // Draw rounded-card outline (for visual cutting aid after lamination)
      roundedRect(doc, x, y, CARD_W, CARD_H, 3);

      // Subtle crop marks (outside the corners)
      drawCropMarks(doc, x, y, CARD_W, CARD_H);

      // Branding bar (top)
      const brandBarH = 10;
      doc.setFillColor(BRAND.primary);
      doc.roundedRect(x, y, CARD_W, brandBarH, 2, 2, "F");

      // Logo + Brand name (white)
      doc.setTextColor(255);
      doc.setFontSize(9);
      const brandText = BRAND.name;
      // Simple logo: if provided, draw image; otherwise text only
      if (logoDataUrl) {
        const imgH = 6;
        const imgW = imgH * 1.2;
        doc.addImage(logoDataUrl, "PNG", x + 3, y + 2, imgW, imgH, undefined, "FAST");
        doc.text(brandText, x + 3 + imgW + 2, y + 6.5);
      } else {
        doc.text(brandText, x + 3, y + 6.5);
      }

      // QR code area
      const cardCx = x + CARD_W / 2;
      const qrX = cardCx - QR_SIZE / 2;
      const qrY = y + 14;

      const qrDataUrl = await makeQrDataUrl(rows[i].number);
      doc.addImage(qrDataUrl, "PNG", qrX, qrY, QR_SIZE, QR_SIZE, undefined, "FAST");

      // Human-readable text (membership number + optional name)
      doc.setTextColor(BRAND.text);
      doc.setFont("helvetica", "bold");
      doc.setFontSize(11);
      centerText(doc, rows[i].number, cardCx, qrY + QR_SIZE + 8);

      if (rows[i].name) {
        doc.setFont("helvetica", "normal");
        doc.setFontSize(9);
        centerText(doc, rows[i].name, cardCx, qrY + QR_SIZE + 14);
      }
    }

    const dateStr = dayjs().format("YYYY-MM-DD");
    const outName = `GKR-QR-Cards-${dateStr}.pdf`;
    doc.save(outName);
  }

  return (
    <div className="min-h-screen bg-neutral-50 text-neutral-900">
      <div className="max-w-6xl mx-auto p-6 space-y-6">
        <h1 className="text-2xl font-bold tracking-tight">GKR QR Card Generator</h1>
        <p className="text-sm text-neutral-600 leading-relaxed">
          100% client‑side. Nothing is uploaded or stored. Close the tab to clear data. CSV columns: <code>MembershipNumber</code> (required) and <code>Name</code> (optional). Output: A4 PDF with credit‑card‑size cards, rounded corners, crop marks, and branding.
        </p>

        <Card className="shadow-sm">
          <CardContent className="p-4 grid gap-4 md:grid-cols-2">
            <div className="space-y-3">
              <label className="text-sm font-medium">Upload CSV</label>
              <Input type="file" accept=".csv" onChange={(e) => handleCsvFile(e.target.files?.[0])} />
              <p className="text-xs text-neutral-500">Columns: MembershipNumber, Name (optional). {csvName && <span className="text-neutral-700">Loaded: {csvName}</span>}</p>

              <div className="space-y-2">
                <label className="text-sm font-medium">Or paste rows (Number,Name)</label>
                <textarea
                  className="w-full h-28 rounded-xl border p-2 text-sm"
                  placeholder={"00131334,Alex Smith\n00098765,Jordan A.\n00011122"}
                  onBlur={(e) => handlePaste(e.target.value)}
                />
                <p className="text-xs text-neutral-500">Paste and click outside the box to parse.</p>
              </div>

              <div className="space-y-2">
                <label className="text-sm font-medium">Logo (PNG/SVG recommended)</label>
                <Input
                  type="file"
                  accept="image/*"
                  onChange={(e) => {
                    const f = e.target.files?.[0];
                    if (!f) return;
                    const reader = new FileReader();
                    reader.onload = () => setLogoDataUrl(reader.result);
                    reader.readAsDataURL(f);
                  }}
                />
                <p className="text-xs text-neutral-500">If omitted, the brand line prints as text only.</p>
              </div>
            </div>

            <div className="space-y-3">
              <div className="flex items-start gap-2 bg-amber-50 border border-amber-200 rounded-xl p-3">
                <AlertTriangle className="w-4 h-4 mt-0.5" />
                <p className="text-sm leading-snug">
                  <strong>Privacy:</strong> All processing happens in your browser. Files never leave your device. No data is stored.
                </p>
              </div>

              <div className="flex items-center gap-3 pt-1">
                <Button onClick={exportPdf} disabled={!rows.length} className="gap-2">
                  <FileDown className="w-4 h-4" /> Export A4 PDF
                </Button>
                <span className="text-sm text-neutral-500">{rows.length ? `${rows.length} record${rows.length===1?"":"s"} ready` : "No records loaded"}</span>
              </div>

              {duplicates.length > 0 && (
                <div className="text-sm text-red-600">
                  Duplicates detected: {duplicates.join(", ")}
                </div>
              )}
            </div>
          </CardContent>
        </Card>

        {/* Preview Grid */}
        <div className="space-y-3">
          <h2 className="text-lg font-semibold">Preview (not exact print rendering)</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {rows.slice(0, 8).map((r, idx) => (
              <div key={idx} className="p-4 rounded-2xl bg-white border shadow-sm">
                <CardPreview number={r.number} name={r.name} logoDataUrl={logoDataUrl} />
              </div>
            ))}
          </div>
          {rows.length > 8 && (
            <p className="text-xs text-neutral-500">Showing first 8 of {rows.length}. All will be included in the PDF.</p>
          )}
        </div>

        <div className="pt-2 text-xs text-neutral-500">
          Tip: Credit‑card size {CARD_W}×{CARD_H}mm, QR ≈ {QR_SIZE}mm. Subtle crop marks are included for trimming prior to laminating.
        </div>
      </div>
    </div>
  );
}

function CardPreview({ number, name, logoDataUrl }) {
  return (
    <div className="relative w-full aspect-[85.6/54] rounded-2xl border overflow-hidden bg-white">
      {/* branding bar */}
      <div className="absolute inset-x-0 top-0 h-10 flex items-center px-3" style={{ background: BRAND.primary }}>
        {logoDataUrl ? (
          <img src={logoDataUrl} alt="logo" className="h-5 w-auto" />
        ) : (
          <div className="text-white font-medium">{BRAND.name}</div>
        )}
      </div>
      {/* QR mock */}
      <div className="absolute top-12 left-1/2 -translate-x-1/2 w-40 h-40 bg-white border rounded-xl grid place-items-center">
        <div className="w-32 h-32 bg-neutral-900" />
      </div>
      <div className="absolute bottom-4 left-0 right-0 text-center">
        <div className="font-semibold tracking-wide">{number}</div>
        {name && <div className="text-sm text-neutral-600">{name}</div>}
      </div>
    </div>
  );
}

// Helpers
function centerText(doc, text, cx, y) {
  const w = doc.getTextWidth(text);
  doc.text(text, cx - w / 2, y);
}

function roundedRect(doc, x, y, w, h, r) {
  // Draw rounded rect path then stroke with light gray
  doc.setDrawColor(200);
  doc.roundedRect(x, y, w, h, r, r, "S");
}

function drawCropMarks(doc, x, y, w, h) {
  const len = 4; // mm
  const off = 1.5; // gap from corner
  doc.setDrawColor(190);
  // top-left
  doc.line(x - off - len, y - off, x - off, y - off);
  doc.line(x - off, y - off - len, x - off, y - off);
  // top-right
  doc.line(x + w + off, y - off, x + w + off + len, y - off);
  doc.line(x + w + off, y - off - len, x + w + off, y - off);
  // bottom-left
  doc.line(x - off - len, y + h + off, x - off, y + h + off);
  doc.line(x - off, y + h + off, x - off, y + h + off + len);
  // bottom-right
  doc.line(x + w + off, y + h + off, x + w + off + len, y + h + off);
  doc.line(x + w + off, y + h + off, x + w + off, y + h + off + len);
}
